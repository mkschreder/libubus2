/*
 * Copyright (C) 2015 Martin Schr√∂der <mkschreder.uk@gmail.com>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2.1
 * as published by the Free Software Foundation
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#include <libutype/avl-cmp.h>
#include "ubus_context.h"
#include "ubus_peer.h"

struct ubus_peer *_find_peer_by_name(struct ubus_context *self, const char *client_name){
	struct avl_node *avl = avl_find(&self->peers_by_name, client_name); 
	if(!avl) return NULL; 
	return container_of(avl, struct ubus_peer, avl_name); 
}

struct ubus_peer *_find_peer_by_id(struct ubus_context *self, uint32_t id){
	struct avl_node *avl = avl_find(&self->peers_by_id, &id); 
	if(!avl) return NULL; 
	return container_of(avl, struct ubus_peer, avl_id); 
}

struct ubus_peer *_create_peer(struct ubus_context *self, uint32_t id){
	char client_name[256]; 
	snprintf(client_name, sizeof(client_name), "00%08x", id); 
	struct ubus_peer *peer = ubus_peer_new(client_name, id); 
	if(avl_insert(&self->peers_by_id, &peer->avl_id) != 0 || avl_insert(&self->peers_by_name, &peer->avl_name) != 0){
		ubus_peer_delete(&peer); 
		return NULL; 
	}
	return peer; 
}

struct ubus_object *_find_object(struct ubus_context *self, const char *path){
	struct avl_node *avl = avl_find(&self->objects, path); 
	if(!avl) return NULL; 
	return container_of(avl, struct ubus_object, avl); 
}

static __attribute__((unused)) int _on_rpc_call(struct ubus_method *self, struct ubus_context *ctx, 
	struct ubus_object *obj, struct ubus_request *req){
	printf("on_rpc_call!\n"); 
	return 0; 
}

void _on_msg_signal(struct ubus_context *self, struct ubus_peer *peer, uint16_t serial, struct blob_attr *msg){
	// first argument is always signal type
	struct blob_attr *attr = blob_attr_first_child(msg); 
	const char *signal_name = blob_attr_get_string(attr); 
	if(!signal_name) return; 

	// check if we have received any message that is of interest to us
	if(strcmp(signal_name, "ubus.object.add") == 0){
		// this is a signal generated by the peer when an object is added on it's other side
		attr = blob_attr_next_child(msg, attr); 
		const char *obj_name = blob_attr_get_string(attr); 
		struct ubus_object *obj = ubus_object_new(obj_name); 
		// parse out all the methods of the peer object and add them as local methods	
		struct blob_attr *signature = blob_attr_next_child(msg, attr); 	
		for(struct blob_attr *method = blob_attr_first_child(signature); 
			method; method = blob_attr_next_child(signature, method)){
			const char *method_name = blob_attr_get_string(method); 
			method = blob_attr_next_child(signature, method); 
			struct ubus_method *m = ubus_method_new(method_name, &_on_rpc_call); 
			ubus_object_add_method(obj, &m); 
		}
		// add the new object to the peer
		ubus_peer_add_object(peer, &obj); 
	} else if(strcmp(signal_name, "ubus.peer.well_known_name") == 0){
		attr = blob_attr_next_child(msg, attr); 
		avl_delete(&self->peers_by_name, &peer->avl_name); 
		//printf("setting name of %s to %s\n",(char*)peer->avl_name.key, blob_attr_get_string(attr)); 
		ubus_peer_set_name(peer, blob_attr_get_string(attr)); 
		if(0 != avl_insert(&self->peers_by_name, &peer->avl_name)){
			// TODO: handle duplicates
		}
		// TODO: handle errors and make sure peers are authenticated
		// send out notification to all clients that peer has connected
		blob_buf_reset(&self->buf); 
		blob_buf_put_string(&self->buf, "ubus.peer.connected"); 
		blob_buf_put_string(&self->buf, peer->name); 
		blob_buf_put_i32(&self->buf, peer->id); 
		ubus_socket_send(&self->socket, UBUS_PEER_BROADCAST, 0, UBUS_MSG_SIGNAL, self->request_seq++, blob_buf_head(&self->buf)); 
	} else if(strcmp(signal_name, "ubus.peer.connected") == 0){
		attr = blob_attr_next_child(msg, attr); 
		const char *peer_name = blob_attr_get_string(attr); 
		attr = blob_attr_next_child(msg, attr); 
		uint32_t peer_id = blob_attr_get_i32(attr); 
		ubus_peer_add_child_peer(peer, peer_name, peer_id); 
	}
}

static void _on_resolve_method_call(struct ubus_request *req, struct blob_attr *msg){
	struct ubus_context *self = (struct ubus_context*)ubus_request_get_userdata(req); 
	struct ubus_peer *peer = _find_peer_by_name(self, req->client); 

	if(!peer) return; 
	
	// send reply with the same serial as the original request
	ubus_socket_send(&self->socket, peer->id, 0, UBUS_MSG_METHOD_RETURN, req->seq, msg);  
}

static void _on_msg_call(struct ubus_context *self, struct ubus_peer *peer, uint16_t serial, struct blob_attr *msg){
	// arg 0: object path
	// arg 1: method name
	// arg 3: arguments
	struct blob_attr *attr = blob_attr_first_child(msg); 
	const char *path = blob_attr_get_string(attr); 
	attr = blob_attr_next_child(msg, attr); 
	const char *method = blob_attr_get_string(attr); 
	attr = blob_attr_next_child(msg, attr); 

	// find the object being refered to in our local list 
	struct ubus_object *obj = _find_object(self, path); 
	if(!obj) return; 
	
	struct ubus_method *m = ubus_object_find_method(obj, method); 
	if(!m) return; 

	printf("found object %s %s\n", path, method); 


	// now we have to create a new request object which we bind to reply functions
	// so that when the application code calls ubus_request_resolve() we can 
	// send back the result over the network to the other peer

	struct ubus_request *req = ubus_request_new(UBUS_LOCAL_BUS, peer->name, path, method, msg); 
	req->seq = serial; 
	ubus_request_set_userdata(req, self); 
	ubus_request_on_resolve(req, &_on_resolve_method_call); 

	// add the request to the list of pending requests 
	list_add(&req->list, &self->pending_incoming); 

	ubus_method_invoke(m, self, obj, req); 
}

static void _on_msg_return(struct ubus_context *self, struct ubus_peer *peer, uint16_t serial, struct blob_attr *msg){
	// find the pending outgoing request that has the same serial 
	struct ubus_request *req, *tmp, *found = NULL; 
	list_for_each_entry_safe(req, tmp, &self->pending, list){
		if(req->seq == serial){
			found = req; 
			break; 
		}
	}
	if(!found) return; 
	ubus_request_resolve(req, msg); 
}

static void _on_message_received(struct ubus_socket *socket, uint32_t dst_peer, uint32_t src_peer, uint8_t type, uint32_t serial, struct blob_attr *msg){
	struct ubus_context *self = (struct ubus_context*)socket->user_data;  
	assert(self); 
	// find the peer 
	struct ubus_peer *p = _find_peer_by_id(self, src_peer);  
	if(!p) return; 
	printf("message from %08x to %08x\n", src_peer, dst_peer); 

	// if message is addressed to another peer than ourselves then we transparently forward it
	if(dst_peer != 0){
		ubus_socket_send(socket, dst_peer, 0, type, serial, msg); 
		return; 
	}

	switch(type){
		case UBUS_MSG_METHOD_CALL: {
			_on_msg_call(self, p, serial, msg); 
			break; 
		}
		case UBUS_MSG_METHOD_RETURN: {
			_on_msg_return(self, p, serial, msg); 
			break; 
		}
		case UBUS_MSG_SIGNAL: {
			_on_msg_signal(self, p, serial, msg); 
			break; 
		}
		case UBUS_MSG_ERROR: {
			break; 
		}
	}

	blob_attr_dump_json(msg); 
}

void _on_client_connected(struct ubus_socket *socket, uint32_t peer_id){
	struct ubus_context *self = (struct ubus_context*)socket->user_data;  
	_create_peer(self, peer_id); 
	printf("peer connected id %08x\n", peer_id); 	
	// send out our name to peer
	blob_buf_reset(&self->buf); 
	blob_buf_put_string(&self->buf, "ubus.peer.well_known_name"); 
	blob_buf_put_string(&self->buf, self->name); 
	ubus_socket_send(&self->socket, peer_id, 0, UBUS_MSG_SIGNAL, self->request_seq++, blob_buf_head(&self->buf)); 
}

void ubus_context_init(struct ubus_context *self, const char *name){
	INIT_LIST_HEAD(&self->requests); 
	INIT_LIST_HEAD(&self->pending); 
	INIT_LIST_HEAD(&self->pending_incoming); 
	avl_init(&self->peers_by_name, avl_intcmp, false, NULL); 
	avl_init(&self->peers_by_id, avl_intcmp, false, NULL); 
	avl_init(&self->objects, avl_strcmp, false, NULL); 
	ubus_socket_init(&self->socket); 
	ubus_socket_set_userdata(&self->socket, self); 
	ubus_socket_on_message(&self->socket, &_on_message_received); 
	ubus_socket_on_client_connected(&self->socket, &_on_client_connected); 
	blob_buf_init(&self->buf, 0, 0); 
	self->name = strdup(name);
	self->request_seq = 1; 
}

void ubus_context_destroy(struct ubus_context *self){
	ubus_socket_destroy(&self->socket); 
	blob_buf_free(&self->buf); 
	free(self->name); 
}

struct ubus_context *ubus_new(const char *name){
	struct ubus_context *self = calloc(1, sizeof(*self)); 
	ubus_context_init(self, name); 
	return self; 
}

void ubus_delete(struct ubus_context **self){
	assert(self); 
	ubus_context_destroy(*self); 
	*self = NULL; 
}

int ubus_connect(struct ubus_context *self, const char *path){
	if(!path) path = UBUS_DEFAULT_SOCKET; 
	return ubus_socket_connect(&self->socket, path); 
}

int ubus_listen(struct ubus_context *self, const char *path){
	return ubus_socket_listen(&self->socket, path); 	
}

int ubus_send_request(struct ubus_context *self, struct ubus_request **_req){
	struct ubus_request *req = *_req; 
	req->seq = self->request_seq++; 
	printf("sending request %08x\n", req->seq); 
	list_add(&req->list, &self->requests); 
	return 0; 
}

int ubus_publish_object(struct ubus_context *self, struct ubus_object **_obj){
	// add the object to our local list of objects and tell all peers that we have this object
	struct ubus_object *obj = *_obj; 
	*_obj = NULL;

	if(avl_insert(&self->objects, &obj->avl) != 0){
		ubus_object_delete(&obj); 
		return -1; 
	}

	blob_buf_reset(&self->buf); 
	blob_buf_put_string(&self->buf, "ubus.object.add"); 
	blob_buf_put_string(&self->buf, obj->name); 
	ubus_object_serialize(obj, &self->buf); 
	ubus_socket_send(&self->socket, UBUS_PEER_BROADCAST, 0, UBUS_MSG_SIGNAL, self->request_seq++, blob_buf_head(&self->buf));   

	return 0; 
}

int ubus_handle_events(struct ubus_context *self){
	// try to send out pending requests
	struct ubus_request *req; 
	struct ubus_request *tmp; 
	list_for_each_entry_safe(req, tmp, &self->pending_incoming, list){
		if(req->failed || req->resolved){
			printf("deleting completed request\n");
			list_del_init(&req->list); 
			ubus_request_delete(&req); 
		}
	}

	list_for_each_entry_safe(req, tmp, &self->requests, list){
		// check if the request has timed out
		// TODO

		// see if we have the target client
		blob_buf_reset(&self->buf); 
		if(req->bus){
			struct ubus_peer *bus_peer = _find_peer_by_name(self, req->bus); 
			if(!bus_peer) continue; 
			struct ubus_peer *peer = ubus_peer_find_child_peer(bus_peer, req->client); 
			if(!peer) continue; 

			printf("found bus peer for request. Bus %08x, Client %08x\n", bus_peer->id, peer->id); 

			//blob_buf_put_string(&self->buf, req->client); 
			blob_buf_put_string(&self->buf, req->object); 
			blob_buf_put_string(&self->buf, req->method); 
			blob_buf_put_attr(&self->buf, blob_buf_head(&req->buf)); 
			ubus_socket_send(&self->socket, bus_peer->id, peer->id, UBUS_MSG_METHOD_CALL, req->seq, blob_buf_head(&self->buf)); 
		} else {
			struct ubus_peer *peer = _find_peer_by_name(self, req->client); 
			if(!peer) continue; 
			
			printf("found peer for request %s %08x\n", req->client, peer->id); 

			//blob_buf_put_string(&self->buf, ""); 
			blob_buf_put_string(&self->buf, req->object); 
			blob_buf_put_string(&self->buf, req->method); 
			blob_buf_put_attr(&self->buf, blob_buf_head(&req->buf)); 
			ubus_socket_send(&self->socket, peer->id, 0, UBUS_MSG_METHOD_CALL, req->seq, blob_buf_head(&self->buf)); 
		}

		// move the request to pending queue
		list_del_init(&req->list); 
		list_add(&req->list, &self->pending); 
	}
	ubus_socket_poll(&self->socket, 0); 
	return 0; 
}
