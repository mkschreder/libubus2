/*
 * Copyright (C) 2015 Martin Schr√∂der <mkschreder.uk@gmail.com>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2.1
 * as published by the Free Software Foundation
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */


#include <libutype/avl-cmp.h>
#include "ubus_context.h"
#include "ubus_peer.h"

struct ubus_peer *_find_peer_by_name(struct ubus_context *self, const char *client_name){
	struct avl_node *avl = avl_find(&self->peers_by_name, client_name); 
	if(!avl) return NULL; 
	return container_of(avl, struct ubus_peer, avl_name); 
}

struct ubus_peer *_find_peer_by_id(struct ubus_context *self, uint32_t id){
	struct avl_node *avl = avl_find(&self->peers_by_id, &id); 
	if(!avl) return NULL; 
	return container_of(avl, struct ubus_peer, avl_id); 
}

struct ubus_peer *_create_peer(struct ubus_context *self, uint32_t id){
	char client_name[256]; 
	snprintf(client_name, sizeof(client_name), "00%08x", id); 
	struct ubus_peer *peer = ubus_peer_new(client_name, id); 
	if(avl_insert(&self->peers_by_id, &peer->avl_id) != 0 || avl_insert(&self->peers_by_name, &peer->avl_name) != 0){
		ubus_peer_delete(&peer); 
		return NULL; 
	}
	return peer; 
}

struct ubus_object *_find_object(struct ubus_context *self, const char *path){
	struct avl_node *avl = avl_find(&self->objects, path); 
	if(!avl) return NULL; 
	return container_of(avl, struct ubus_object, avl); 
}

static __attribute__((unused)) int _on_rpc_call(struct ubus_context *ctx, struct ubus_object *obj,
		  struct ubus_request *req, const char *method,
		  struct blob_attr *msg){
	printf("on_rpc_call!\n"); 
	return 0; 
}

void _on_msg_signal(struct ubus_context *self, struct ubus_peer *peer, uint16_t serial, struct blob_attr *msg){
	// first argument is always signal type
	struct blob_attr *attr = blob_attr_first_child(msg); 
	const char *signal_name = blob_attr_get_string(attr); 
	if(!signal_name) return; 

	// check if we have received any message that is of interest to us
	if(strcmp(signal_name, "ubus.object.add") == 0){
		// this is a signal generated by the peer when an object is added on it's other side
		attr = blob_attr_next_child(msg, attr); 
		const char *obj_name = blob_attr_get_string(attr); 
		struct ubus_object *obj = ubus_object_new(obj_name); 
		// parse out all the methods of the peer object and add them as local methods	
		struct blob_attr *signature = blob_attr_next_child(msg, attr); 	
		for(struct blob_attr *method = blob_attr_first_child(signature); 
			method; method = blob_attr_next_child(signature, method)){
			const char *method_name = blob_attr_get_string(method); 
			method = blob_attr_next_child(signature, method); 
			struct ubus_method *m = ubus_method_new(method_name, &_on_rpc_call); 
			ubus_object_add_method(obj, &m); 
		}
		// add the new object to the peer
		ubus_peer_add_object(peer, &obj); 
	} else if(strcmp(signal_name, "ubus.peer.well_known_name") == 0){
		attr = blob_attr_next_child(msg, attr); 
		avl_delete(&self->peers_by_name, &peer->avl_name); 
		printf("setting name of %s to %s\n",(char*)peer->avl_name.key, blob_attr_get_string(attr)); 
		ubus_peer_set_name(peer, blob_attr_get_string(attr)); 
		if(0 != avl_insert(&self->peers_by_name, &peer->avl_name)){
			// TODO: handle duplicates
		}
		// TODO: handle errors and make sure peers are authenticated
	}
}

static void _on_msg_call(struct ubus_context *self, struct ubus_peer *peer, uint16_t serial, struct blob_attr *msg){
	// arg 0: object path
	// arg 1: method name
	// arg 3: arguments
	struct blob_attr *attr = blob_attr_first_child(msg); 
	const char *path = blob_attr_get_string(attr); 
	attr = blob_attr_next_child(msg, attr); 
	const char *method = blob_attr_get_string(attr); 
	attr = blob_attr_next_child(msg, attr); 

	// find the object being refered to in our local list 
	struct ubus_object *obj = _find_object(self, path); 
	if(!obj) return; 
	
	struct ubus_method *m = ubus_object_find_method(obj, method); 
	if(!m) return; 
	
	//struct ubus_request *req = ubus_request_new(peer->name, path, method, msg); 

	//ubus_method_invoke(m, self, req); 

	//ubus_method_invoke(m, msg); 
	printf("found object %s %s\n", path, method); 
}

static void _on_message_received(struct ubus_socket *socket, uint32_t peer, uint8_t type, uint32_t serial, struct blob_attr *msg){
	struct ubus_context *self = (struct ubus_context*)socket->user_data;  
	assert(self); 
	// find the peer 
	struct ubus_peer *p = _find_peer_by_id(self, peer);  
	if(!p) return; 
	printf("message from %08x\n", peer); 
	
	switch(type){
		case UBUS_MSG_METHOD_CALL: {
			_on_msg_call(self, p, serial, msg); 
			break; 
		}
		case UBUS_MSG_METHOD_RETURN: {
			break; 
		}
		case UBUS_MSG_SIGNAL: {
			_on_msg_signal(self, p, serial, msg); 
			break; 
		}
		case UBUS_MSG_ERROR: {
			break; 
		}
	}

	blob_attr_dump_json(msg); 
}

void _on_client_connected(struct ubus_socket *socket, uint32_t peer_id){
	struct ubus_context *self = (struct ubus_context*)socket->user_data;  
	_create_peer(self, peer_id); 
	printf("peer connected id %08x\n", peer_id); 	
	// send out our name to peer
	blob_buf_reset(&self->buf); 
	blob_buf_put_string(&self->buf, "ubus.peer.well_known_name"); 
	blob_buf_put_string(&self->buf, self->name); 
	ubus_socket_send(&self->socket, peer_id, UBUS_MSG_SIGNAL, self->request_seq++, blob_buf_head(&self->buf)); 
}

void ubus_context_init(struct ubus_context *self, const char *name){
	INIT_LIST_HEAD(&self->requests); 
	INIT_LIST_HEAD(&self->pending); 
	avl_init(&self->peers_by_name, avl_intcmp, false, NULL); 
	avl_init(&self->peers_by_id, avl_intcmp, false, NULL); 
	avl_init(&self->objects, avl_strcmp, false, NULL); 
	ubus_socket_init(&self->socket); 
	ubus_socket_set_userdata(&self->socket, self); 
	ubus_socket_on_message(&self->socket, &_on_message_received); 
	ubus_socket_on_client_connected(&self->socket, &_on_client_connected); 
	blob_buf_init(&self->buf, 0, 0); 
	self->name = strdup(name);
}

void ubus_context_destroy(struct ubus_context *self){
	ubus_socket_destroy(&self->socket); 
	blob_buf_free(&self->buf); 
	free(self->name); 
}

struct ubus_context *ubus_new(const char *name){
	struct ubus_context *self = calloc(1, sizeof(*self)); 
	ubus_context_init(self, name); 
	return self; 
}

void ubus_delete(struct ubus_context **self){
	assert(self); 
	ubus_context_destroy(*self); 
	*self = NULL; 
}

int ubus_connect(struct ubus_context *self, const char *path){
	if(!path) path = UBUS_DEFAULT_SOCKET; 
	return ubus_socket_connect(&self->socket, path); 
}

int ubus_listen(struct ubus_context *self, const char *path){
	return ubus_socket_listen(&self->socket, path); 	
}

int ubus_send_request(struct ubus_context *self, struct ubus_request **_req){
	struct ubus_request *req = *_req; 
	list_add(&req->list, &self->requests); 
	return 0; 
}

int ubus_publish_object(struct ubus_context *self, struct ubus_object **_obj){
	// add the object to our local list of objects and tell all peers that we have this object
	struct ubus_object *obj = *_obj; 
	*_obj = NULL;

	if(avl_insert(&self->objects, &obj->avl) != 0){
		ubus_object_delete(&obj); 
		return -1; 
	}

	blob_buf_reset(&self->buf); 
	blob_buf_put_string(&self->buf, "ubus.object.add"); 
	blob_buf_put_string(&self->buf, obj->name); 
	ubus_object_serialize(obj, &self->buf); 
	ubus_socket_send(&self->socket, UBUS_PEER_BROADCAST, UBUS_MSG_SIGNAL, self->request_seq++, blob_buf_head(&self->buf));   

	return 0; 
}

int ubus_handle_events(struct ubus_context *self){
	// try to send out pending requests
	struct ubus_request *req; 
	struct ubus_request *tmp; 
	list_for_each_entry_safe(req, tmp, &self->requests, list){
		// check if the request has timed out
		// TODO

		// see if we have the target client
		struct ubus_peer *peer = _find_peer_by_name(self, req->client); 
		if(!peer) continue; 

		printf("found peer for request %s %08x\n", req->client, peer->id); 
		// send the message to that peer

		// make an invocation
		blob_buf_reset(&self->buf); 
		blob_buf_put_string(&self->buf, req->object); 
		blob_buf_put_string(&self->buf, req->method); 
		blob_buf_put_attr(&self->buf, blob_buf_head(&req->buf)); 
		ubus_socket_send(&self->socket, peer->id, UBUS_MSG_METHOD_CALL, self->request_seq++, blob_buf_head(&self->buf)); 

		// move the request to pending queue
		list_del_init(&req->list); 
		list_add(&req->list, &self->pending); 
	}
	ubus_socket_poll(&self->socket, 0); 
	return 0; 
}
